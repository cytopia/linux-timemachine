#!/bin/sh -eu
#
# https://serverfault.com/questions/834994/rsync-only-keep-10-backup-folders
export PATH=/bin:/usr/bin

################################################################################
# Variables
################################################################################

# Credit variables
MY_NAME="timemachine"
MY_DESC="OSX-like timemachine cli script for Linux and BSD (and even OSX)"
MY_PROJ="https://github.com/cytopia/linux-timemachine"
MY_AUTH="cytopia"
MY_MAIL="cytopia@everythingcli.org"
MY_VERS="1.3.1"
MY_DATE="2021-11-28"

# Default command line arguments
VERBOSE=
PORT=
KEY=

# Default variables
SSH_ARGS="-oStrictHostKeyChecking=no -oLogLevel=QUIET -q"



################################################################################
# Functions
################################################################################

print_usage() {
	echo "Usage: ${MY_NAME} [-vd]   <source> <dest> -- [rsync opts]"
	echo

	echo "       ${MY_NAME} [-vdpi] <source> <host>:<dest>        -- [rsync opts]"
	echo "       ${MY_NAME} [-vdpi] <source> <user>@<host>:<dest> -- [rsync opts]"
	echo "       ${MY_NAME} [-vdpi] <source> <ssh-alias>:<dest>   -- [rsync opts]"
	echo

	echo "       ${MY_NAME} [-vdpi] <host>:<source>        <dest> -- [rsync opts]"
	echo "       ${MY_NAME} [-vdpi] <user>@<host>:<source> <dest> -- [rsync opts]"
	echo "       ${MY_NAME} [-vdpi] <ssh-alias>:<source>   <dest> -- [rsync opts]"
	echo

	echo "       ${MY_NAME} -V, --version"
	echo "       ${MY_NAME} -h, --help"
	echo

	echo "This shell script mimics the behavior of OSX's timemachine."
	echo "It uses rsync to incrementally back up your data to a different directory or remote server via SSH."
	echo "All operations are incremental, atomic and automatically resumable."
	echo

	echo "By default it uses --recursive --perms --owner --group --times --links."
	echo "In case your target filesystem does not support any of those options, you can explicitly"
	echo "disable those options via --no-perms --no-owner --no-group --no-times and --copy-links."
	echo

	echo "Required arguments:"
	echo "  <source>              Local source directory"
	echo "  <dest>                Local destination directory."
	echo "  <host>:<dest>         SSH host and source/destination directory on server"
	echo "  <user>@<host>:<dest>  SSH user, SSH host and source/destination directory on server"
	echo "  <ssh-alias>:<dest>    SSH alias (defined in ~/.ssh/config) and source/destination directory on server"
	echo

	echo "Options:"
	echo "  -p, --port            Specify alternative SSH port for remote backups if it is not 22."
	echo "  -i, --identity        Specify path to SSH key."
	echo "  -v, --verbose         Be verbose."
	echo "  -d, --debug           Be even more verbose."
	echo

	echo "Misc Options:"
	echo "  -V, --version         Print version information and exit"
	echo "  -h, --help            Show this help screen"
	echo

	echo "Examples:"
	echo "  Simply back up one directory recursively"
	echo "      timemachine /home/user /data"
	echo "  Do the same, but be verbose"
	echo "      timemachine -v /home/user /data"
	echo "  Append rsync options and be very verbose"
	echo "      timemachine -d /home/user /data -- --progress --verbose"
	echo "  Log to file"
	echo "      timemachine -v /home/user /data > /var/log/timemachine.log 2> /var/log/timemachine.err"
	echo

	echo "Documentation:"
	echo "  View more examples at: ${MY_PROJ}"
}

print_version() {
	echo "${MY_NAME} v${MY_VERS} (${MY_DATE})"
	echo "${MY_DESC}"
	echo
	echo "Copyright (c) 2017 ${MY_AUTH} <${MY_MAIL}>"
	echo "${MY_PROJ}"
}

logdebug() {
	# Only log to stdout when verbose is turned on
	if [ "${VERBOSE}" = "debug" ]; then
		echo "$(date +'%Y-%m-%d %H:%M:%S') ${MY_NAME}: [DEBUG] ${*}"
	fi
}

logmsg() {
	# Only log to stdout when verbose/debug is turned on
	if [ "${VERBOSE}" = "verbose" ] || [ "${VERBOSE}" = "debug" ]; then
		echo "$(date +'%Y-%m-%d %H:%M:%S') ${MY_NAME}: [INFO]  ${*}"
	fi
}

logerr() {
	echo "$(date +'%Y-%m-%d %H:%M:%S') ${MY_NAME}: [ERROR] ${*}" >&2
}

###
### POSIX compliant path escape (like printf "%q" in bash)
###
escape_path() {
	# https://mullikine.github.io/posts/missing-posix-shell-functions-cmd-and-myeval/
	for var in "$@"; do
		printf "'%s' " "$(printf %s "$var" | sed "s/'/'\\\\''/g")";
	done | sed 's/ $//'
}

###
### Check if the destination is a remote server
###
is_remote() {
	echo "${1}" | grep -E '.+:.+' >/dev/null
}

###
### Check if a directory exists locally or remotely
###
dir_exists() {
	directory="${1}"

	if is_remote "${directory}"; then
		ssh_part="$( echo "${directory}" | awk -F':' '{print $1}' )"
		dir_part="$( echo "${directory}" | awk -F':' '{print $2}' )"
		cmd="ssh ${SSH_ARGS} ${ssh_part} 'test -d \"${dir_part}\"'"
	else
		cmd="test -d ${directory}"
	fi
	logdebug "${cmd}"
	eval "${cmd}" >/dev/null
}

###
### Check if a symlink exists locally or remotely
###
link_exists() {
	directory="${1}"

	if is_remote "${directory}"; then
		ssh_part="$( echo "${directory}" | awk -F':' '{print $1}' )"
		dir_part="$( echo "${directory}" | awk -F':' '{print $2}' )"
		cmd="ssh ${SSH_ARGS} ${ssh_part} 'test -L \"${dir_part}\"'"
	else
		cmd="test -L ${directory}"
	fi
	logdebug "${cmd}"
	eval "${cmd}" >/dev/null
}

###
### Remove local or remote file
###
remove_file() {
	file="${1}"

	if is_remote "${file}"; then
		ssh_part="$( echo "${file}" | awk -F':' '{print $1}' )"
		file_part="$( echo "${file}" | awk -F':' '{print $2}' )"
		cmd="ssh ${SSH_ARGS} ${ssh_part} 'rm \"${file_part}\"'"
	else
		cmd="rm ${file}"
	fi
	logdebug "${cmd}"
	eval "${cmd}" >/dev/null
}

###
### Rename local or remote directory
###
rename_directory() {
	from="${1}"
	to="${2}"

	if is_remote "${from}"; then
		ssh_part="$( echo "${from}" | awk -F':' '{print $1}' )"
		dir_from_part="$( echo "${from}" | awk -F':' '{print $2}' )"
		dir_to_part="$( echo "${to}" | awk -F':' '{print $2}' )"
		cmd="ssh ${SSH_ARGS} ${ssh_part} 'mv \"${dir_from_part}\" \"${dir_to_part}\"'"
	else
		cmd="mv ${from} ${to}"
	fi
	logdebug "${cmd}"
	eval "${cmd}" >/dev/null
}

###
### Symlink local or remote directory
###
link_directory() {
	dir="${1}"
	lnk="${2}"

	if is_remote "${lnk}"; then
		ssh_part="$( echo "${lnk}" | awk -F':' '{print $1}' )"
		lnk_part="$( echo "${lnk}" | awk -F':' '{print $2}' )"
		cmd="ssh ${SSH_ARGS} ${ssh_part} 'ln -s \"${dir}\" \"${lnk_part}\"'"
	else
		cmd="ln -s ${dir} ${lnk}"
	fi
	logdebug "${cmd}"
	eval "${cmd}" >/dev/null
}



################################################################################
# Entrypoint: Parse cmd args
################################################################################

# Parse input args with getopts
while test "${#}" -gt 0; do
	case "${1}" in
		# ---------- Help / version ----------
		-V | --version)
			print_version
			exit
			;;
		-h | --help)
			print_usage
			exit
			;;
		# ---------- Verbosity ----------
		-v | --verbose)
			if [ "${VERBOSE}" != "debug" ]; then
				VERBOSE="verbose"
			fi
			shift
			;;
		-d | --debug)
			VERBOSE="debug"
			shift
			;;
		# ---------- Options ----------
		-p | --port)
			if [ -z "${2:-}" ]; then
				logerr "${1} requires an argument, see -h for help."
				exit 2
			fi
			shift
			PORT="${1}"
			SSH_ARGS="${SSH_ARGS} -p ${PORT}"
			shift
			;;
		-i | --identity)
			if [ -z "${2:-}" ]; then
				logerr "${1} requires an argument, see -h for help."
				exit 2
			fi
			shift
			KEY="${1}"
			SSH_ARGS="${SSH_ARGS} -i ${KEY}"
			shift
			;;
		-*)
			if [ "${1}" != "--" ]; then
				logerr "Unknown option ${1}, see -h for help."
				exit 2
			fi
			shift
			;;
		*)
			# No more options available, so break and evaluate
			# positional arguments.
			break
	esac
done



################################################################################
# Entrypoint: Validate cmd args
################################################################################

if [ "${#}" -lt "2" ]; then
	logerr "<source> and <destination> are required. See -h for help."
	exit 1
fi

if is_remote "$( escape_path "${1}" )"; then
	if is_remote "$( escape_path "${2}" )"; then
		logerr "Source and Target cannot both be remote locations."
		exit 1
	fi
fi

if ! dir_exists "$( escape_path "${1}" )"; then
	logerr "Source directory does not exist: '${1}'. See -h for help."
	exit 1
fi
if ! dir_exists "$( escape_path "${2}" )"; then
	logerr "Target directory does not exist: '${2}'. See -h for help."
	exit 1
fi

if ! command -v rsync >/dev/null 2>&1; then
	logerr "rsync binary not found but required."
	exit 1
fi



################################################################################
# Main Entrypoint
################################################################################

# Get arguments and remove them afterwards to have ${@} contain
# all additional rsync options
SRC="$( escape_path "${1}" )"
DEST="$( escape_path "${2}" )"
shift 2
[ "${#}" -ge 1 ] && [ "${1}" = "--" ] && shift

# Name of the backup directory
BACKUP="$( date '+%Y-%m-%d__%H-%M-%S' )"

# Name of the backup directory which is currently in progress (incomplete)
# Used for atomic backups
BACKUP_INPROGRESS=".inprogress"

# Name of the symlink pointing to the latest successful backup
BACKUP_LATEST="current"

# Rsync partial directory to store partially transferred files
# in order to speed up a possible resume for the next run
RSYNC_PARTIAL=".partial"


###
### 1/3 Incremental, resumable and atomic rsync backup
###

# [incremental] --link-dest:          Used to hardlink files which are equal (instead of re-copying them)
# [resume]      --partial-dir:        Where to store unfinished files for resume
# [atomic]      ${BACKUP_INPROGRESS}: Tmp dest dir for atomic operations

BTYPE=

# Only link destination if it already exists
if link_exists "${DEST}/${BACKUP_LATEST}"; then
	BTYPE="incremental"
	logmsg "Starting incremental backup"
	logmsg "\$ rsync $* ${SRC} ${DEST}/${BACKUP_INPROGRESS}"

	eval "rsync \
		-e 'ssh ${SSH_ARGS}' \
		--recursive \
		--perms \
		--owner \
		--group \
		--times \
		--links \
		--delete \
		--delete-excluded \
		--partial-dir=${RSYNC_PARTIAL} \
		--link-dest=../${BACKUP_LATEST} \
		$* \
		${SRC} ${DEST}/${BACKUP_INPROGRESS}"
else
	BTYPE="full"
	logmsg "Starting full backup"
	logmsg "\$ rsync $* ${SRC} ${DEST}/${BACKUP_INPROGRESS}"

	eval "rsync \
		-e 'ssh ${SSH_ARGS}' \
		--recursive \
		--perms \
		--owner \
		--group \
		--times \
		--links \
		--delete \
		--delete-excluded \
		--partial-dir=${RSYNC_PARTIAL} \
		$* \
		${SRC} ${DEST}/${BACKUP_INPROGRESS}"
fi


###
### 2/3 Finish atomic operation
###

# Move temporary atomic directory to chosen dest directory
logmsg "\$ mv ${DEST}/${BACKUP_INPROGRESS} ${DEST}/${BACKUP}"
rename_directory "${DEST}/${BACKUP_INPROGRESS}" "${DEST}/${BACKUP}"


###
### 3/3 Latest symlink
###

# Remove current 'latest' symlink
if link_exists "${DEST}/${BACKUP_LATEST}"; then
	logmsg "\$ rm ${DEST}/${BACKUP_LATEST}"
	remove_file "${DEST}/${BACKUP_LATEST}"
fi

# Set new 'latest' link-dest for incremental backups
logmsg "\$ ln -s ${BACKUP} ${DEST}/${BACKUP_LATEST}"
link_directory "${BACKUP}" "${DEST}/${BACKUP_LATEST}"


###
### Finished
###
logmsg "Finished ${BTYPE} backup"
